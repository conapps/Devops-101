import { Test } from 'nodeunit';
declare const _default: {
    'the Permission class is a programming model for iam'(test: Test): void;
    'the PolicyDocument class is a dom for iam policy documents'(test: Test): void;
    'Permission allows specifying multiple actions upon construction'(test: Test): void;
    'PolicyDoc resolves to undefined if there are no permissions'(test: Test): void;
    'canonicalUserPrincipal adds a principal to a policy with the passed canonical user id'(test: Test): void;
    'addAccountRootPrincipal adds a principal with the current account root'(test: Test): void;
    'addFederatedPrincipal adds a Federated principal with the passed value'(test: Test): void;
    'addAwsAccountPrincipal can be used multiple times'(test: Test): void;
    'hasResource': {
        'false if there are no resources'(test: Test): void;
        'true if there is one resource'(test: Test): void;
        'true for multiple resources'(test: Test): void;
    };
    'hasPrincipal': {
        'false if there is no principal'(test: Test): void;
        'true if there is a principal'(test: Test): void;
    };
    'statementCount returns the number of statement in the policy document'(test: Test): void;
    '{ AWS: "*" } principal': {
        'is represented as `Anyone`'(test: Test): void;
        'is represented as `AnyPrincipal`'(test: Test): void;
        'is represented as `addAnyPrincipal`'(test: Test): void;
    };
    'addResources() will not break a list-encoded Token'(test: Test): void;
    'addCanonicalUserPrincipal can be used to add cannonical user principals'(test: Test): void;
    'addPrincipal correctly merges array in'(test: Test): void;
    'policy statements with multiple principal types can be created using multiple addPrincipal calls'(test: Test): void;
    'Service principals': {
        'regional service principals resolve appropriately'(test: Test): void;
        'regional service principals resolve appropriately (with user-set region)'(test: Test): void;
        'obscure service principals resolve to the user-provided value'(test: Test): void;
    };
    'CompositePrincipal can be used to represent a principal that has multiple types': {
        'with a single principal'(test: Test): void;
        'conditions are not allowed on individual principals of a composite'(test: Test): void;
        'principals and conditions are a big nice merge'(test: Test): void;
        'cannot mix types of assumeRoleAction in a single composite'(test: Test): void;
    };
    'duplicate statements': {
        'without tokens'(test: Test): void;
        'with tokens'(test: Test): void;
    };
    'autoAssignSids enables auto-assignment of a unique SID for each statement'(test: Test): void;
    'constructor args are equivalent to mutating in-place'(test: Test): void;
};
export = _default;
